/**
 * Generate .env files for Next.js applications from secrets
 */

import * as path from 'path';
import { logger } from '../logger';
import { LOCAL_SECRETS_FILE, USER_SECRETS_FILE } from '../../constants';
import { findProjectRoot } from '../paths';
import { getServicePath } from '../paths/get-service-path';
import { writeTextFile, readJsonFile } from '../fs';
import type { FrameworkConfig } from '../config';
import type { SecretsFile } from './types';

/**
 * Generate .env file for a single Next.js service
 *
 * @param serviceName - Name of the Next.js service
 * @param serviceSecrets - Secrets for this service from .secrets.local.json
 * @param rootDir - Project root directory
 */
function generateServiceEnvFile(
  serviceName: string,
  serviceSecrets: Record<string, unknown>,
  rootDir: string
): void {
  // Build env file content
  const header = `################################################################################
# ⚠️  AUTO-GENERATED BY TSDEVSTACK - DO NOT EDIT ⚠️
################################################################################
# Generated from: ${LOCAL_SECRETS_FILE}
# Generated at: ${new Date().toISOString()}
#
# This file is automatically created and OVERWRITTEN when you run:
#   npx tsdevstack generate-secrets
#
# To add or modify secrets:
#   1. Edit ${USER_SECRETS_FILE} (for your custom secrets)
#   2. Run: npx tsdevstack generate-secrets
#   3. This file will be regenerated automatically
#
# ⚠️  DO NOT EDIT THIS FILE DIRECTLY - ALL CHANGES WILL BE LOST! ⚠️
################################################################################

`;

  const envLines: string[] = [header];

  // Convert secrets to KEY=VALUE format
  for (const [key, value] of Object.entries(serviceSecrets)) {
    // Skip NODE_ENV - it interferes with Next.js builds
    // Next.js handles NODE_ENV automatically based on dev/build/start commands
    if (key === 'NODE_ENV') {
      continue;
    }

    // Skip non-string values (PORT, secrets array, etc.)
    if (typeof value !== 'string') {
      continue;
    }

    // Escape special characters in values
    const escapedValue = value.replace(/\$/g, '\\$').replace(/"/g, '\\"');
    envLines.push(`${key}=${escapedValue}`);
  }

  // Write to .env in service directory
  const servicePath = getServicePath(serviceName, rootDir);
  const envPath = path.join(servicePath, '.env');
  writeTextFile(envPath, envLines.join('\n') + '\n');

  logger.success(`Generated .env for ${serviceName}`);
}

/**
 * Generate .env files for all Next.js applications
 * Reads service sections from .secrets.local.json and creates individual .env files
 *
 * @param config - Framework configuration
 * @param rootDir - Project root directory (defaults to findProjectRoot())
 */
export function generateNextjsEnvFiles(
  config: FrameworkConfig,
  rootDir: string = findProjectRoot()
): void {
  // Load structured secrets from .secrets.local.json
  const secretsPath = path.join(rootDir, LOCAL_SECRETS_FILE);
  const secretsFile = readJsonFile<SecretsFile>(secretsPath);

  // Get top-level secrets for resolving references
  const topLevelSecrets = secretsFile.secrets || {};

  // Count Next.js services for logging
  let nextjsCount = 0;

  // Process each service
  for (const service of config.services) {
    // Only process Next.js services
    if (service.type !== 'nextjs') {
      continue;
    }

    nextjsCount++;

    // Get this service's secrets section
    const serviceSection = secretsFile[service.name];

    if (!serviceSection || typeof serviceSection !== 'object') {
      logger.warn(`No secrets found for ${service.name} in ${LOCAL_SECRETS_FILE}`);
      continue;
    }

    // Resolve secrets references
    const resolvedSecrets: Record<string, unknown> = {};

    // Get the secrets array from the service section
    const secretsArray = 'secrets' in serviceSection ? serviceSection.secrets : undefined;
    if (Array.isArray(secretsArray)) {
      for (const secretKey of secretsArray) {
        if (typeof secretKey === 'string' && topLevelSecrets[secretKey]) {
          resolvedSecrets[secretKey] = topLevelSecrets[secretKey];
        }
      }
    }

    // Add direct key-value pairs from service section (excluding 'secrets' array)
    for (const [key, value] of Object.entries(serviceSection)) {
      if (key !== 'secrets' && typeof value === 'string') {
        resolvedSecrets[key] = value;
      }
    }

    // Generate .env file for this service
    generateServiceEnvFile(service.name, resolvedSecrets, rootDir);
  }

  if (nextjsCount === 0) {
    logger.info('No Next.js services found - skipping .env generation');
  }
}