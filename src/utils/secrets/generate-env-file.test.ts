import { describe, it, expect, rs, beforeEach, afterEach } from '@rstest/core';
import { generateEnvFile } from './generate-env-file';
import * as loadLocalSecretsModule from './load-local-secrets';
import * as fsModule from '../fs';
import * as pathsModule from '../paths';

// Mock dependencies
rs.mock('./load-local-secrets', { mock: true });
rs.mock('../fs', { mock: true });
rs.mock('../paths', { mock: true });
rs.mock('../logger', () => ({
  logger: {
    success: rs.fn(),
  },
}));

describe('generateEnvFile', () => {
  const mockRootDir = '/test/project';

  beforeEach(() => {
    rs.clearAllMocks();
    rs.mocked(pathsModule.findProjectRoot).mockReturnValue(mockRootDir);
  });

  afterEach(() => {
    rs.restoreAllMocks();
  });

  describe('Basic functionality', () => {
    it('should generate .env file from secrets', () => {
      const mockSecretsFile = {
        secrets: {
          API_KEY: 'test-key-123',
          DATABASE_URL: 'postgresql://user:pass@localhost:5432/db',
        },
      };

      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue(
        mockSecretsFile,
      );

      generateEnvFile(mockRootDir);

      expect(fsModule.writeTextFile).toHaveBeenCalledWith(
        `${mockRootDir}/.env`,
        expect.stringContaining('API_KEY=test-key-123'),
      );
      expect(fsModule.writeTextFile).toHaveBeenCalledWith(
        `${mockRootDir}/.env`,
        expect.stringContaining(
          'DATABASE_URL=postgresql://user:pass@localhost:5432/db',
        ),
      );
    });

    it('should load secrets from loadLocalSecretsFile', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {},
      });

      generateEnvFile(mockRootDir);

      expect(loadLocalSecretsModule.loadLocalSecretsFile).toHaveBeenCalledWith(
        mockRootDir,
      );
    });

    it('should write to .env in project root', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          TEST_KEY: 'value',
        },
      });

      generateEnvFile(mockRootDir);

      expect(fsModule.writeTextFile).toHaveBeenCalledWith(
        `${mockRootDir}/.env`,
        expect.any(String),
      );
    });
  });

  describe('Header generation', () => {
    it('should include warning header', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {},
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toContain('AUTO-GENERATED BY TSDEVSTACK');
      expect(writtenContent).toContain('DO NOT EDIT');
    });

    it('should include generation timestamp', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {},
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toContain('Generated at:');
    });

    it('should include instructions', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {},
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toContain('.secrets.user.json');
      expect(writtenContent).toContain('npx tsdevstack generate-secrets');
    });
  });

  describe('Special character escaping', () => {
    it('should escape dollar signs in values', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          TEST_VAR: 'value$with$dollars',
        },
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toContain('TEST_VAR=value\\$with\\$dollars');
    });

    it('should escape double quotes in values', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          TEST_VAR: 'value"with"quotes',
        },
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toContain('TEST_VAR=value\\"with\\"quotes');
    });

    it('should escape both dollar signs and quotes', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          TEST_VAR: 'value$with"both',
        },
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toContain('TEST_VAR=value\\$with\\"both');
    });
  });

  describe('NODE_ENV handling', () => {
    it('should skip NODE_ENV from secrets', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          NODE_ENV: 'production',
          OTHER_KEY: 'value',
        },
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).not.toContain('NODE_ENV=');
      expect(writtenContent).toContain('OTHER_KEY=value');
    });

    it('should only skip NODE_ENV, not other ENV variables', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          NODE_ENV: 'production',
          NODE_OPTIONS: '--max-old-space-size=4096',
          API_KEY: 'test',
        },
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).not.toContain('NODE_ENV=');
      expect(writtenContent).toContain('NODE_OPTIONS=');
      expect(writtenContent).toContain('API_KEY=');
    });
  });

  describe('Default rootDir behavior', () => {
    it('should use findProjectRoot when rootDir not provided', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {},
      });

      generateEnvFile();

      expect(pathsModule.findProjectRoot).toHaveBeenCalled();
      expect(loadLocalSecretsModule.loadLocalSecretsFile).toHaveBeenCalledWith(
        mockRootDir,
      );
    });
  });

  describe('KEY=VALUE format', () => {
    it('should generate correct KEY=VALUE format', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          API_KEY: 'abc123',
          DATABASE_URL: 'postgresql://localhost/db',
        },
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toMatch(/API_KEY=abc123/);
      expect(writtenContent).toMatch(
        /DATABASE_URL=postgresql:\/\/localhost\/db/,
      );
    });

    it('should handle empty string values', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          EMPTY_VAR: '',
        },
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toContain('EMPTY_VAR=');
    });

    it('should convert non-string values to strings', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          PORT: '3000',
          ENABLED: 'true',
        },
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toContain('PORT=3000');
      expect(writtenContent).toContain('ENABLED=true');
    });
  });

  describe('Multiple secrets', () => {
    it('should handle multiple secrets correctly', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          API_KEY: 'key1',
          DATABASE_URL: 'url1',
          REDIS_URL: 'redis://localhost',
          AUTH_SECRET: 'secret123',
        },
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toContain('API_KEY=key1');
      expect(writtenContent).toContain('DATABASE_URL=url1');
      expect(writtenContent).toContain('REDIS_URL=redis://localhost');
      expect(writtenContent).toContain('AUTH_SECRET=secret123');
    });
  });

  describe('File ending', () => {
    it('should end with newline', () => {
      rs.mocked(loadLocalSecretsModule.loadLocalSecretsFile).mockReturnValue({
        secrets: {
          TEST_KEY: 'value',
        },
      });

      generateEnvFile(mockRootDir);

      const writtenContent = rs.mocked(fsModule.writeTextFile).mock.calls[0][1];
      expect(writtenContent).toMatch(/\n$/);
    });
  });
});
