import { describe, it, expect, rs, beforeEach } from '@rstest/core';
import { generateFrameworkSecretsFile } from './generate-framework-secrets-file';
import { createMockFrameworkConfig } from '../../test-fixtures/framework-config';
import type { SecretsFile } from './types';
import * as generateDatabaseSecretsModule from './generate-database-secrets';
import * as generateBase64SecretModule from './generate-base64-secret';
import * as generateHexSecretModule from './generate-hex-secret';
import * as generateRSAKeyPairModule from './generate-rsa-keypair';

// Mock dependencies
rs.mock('./generate-database-secrets', { mock: true });
rs.mock('./generate-base64-secret', { mock: true });
rs.mock('./generate-hex-secret', { mock: true });
rs.mock('./generate-rsa-keypair', { mock: true });

describe('generateFrameworkSecretsFile', () => {
  beforeEach(() => {
    rs.clearAllMocks();
    rs.mocked(generateBase64SecretModule.generateBase64Secret).mockReturnValue(
      'mocked-base64-secret',
    );
    rs.mocked(generateHexSecretModule.generateHexSecret).mockReturnValue(
      'mocked-hex-secret',
    );
    rs.mocked(generateRSAKeyPairModule.generateRSAKeyPair).mockReturnValue({
      privateKey: 'mocked-private-key',
      publicKey: 'mocked-public-key',
      keyId: 'mocked-key-id',
    });
    rs.mocked(
      generateDatabaseSecretsModule.generateDatabaseSecrets,
    ).mockReturnValue({
      password: 'db-password',
      username: 'db-user',
      database: 'db-name',
      url: 'postgresql://db-user:db-password@localhost:5432/db-name',
    });
  });

  describe('Basic structure', () => {
    it('should generate file with metadata fields', () => {
      const config = createMockFrameworkConfig();

      const result = generateFrameworkSecretsFile(config);

      expect(result.$comment).toBe(
        'AUTO-GENERATED by tsdevstack - DO NOT EDIT',
      );
      expect(result.$warning).toContain('regenerated');
      expect(result.$regenerate).toBe(
        'Safe to delete - will be recreated automatically',
      );
      expect(result.$generated_at).toBeDefined();
    });

    it('should include flattened REDIS configuration', () => {
      const config = createMockFrameworkConfig();

      const result = generateFrameworkSecretsFile(config);

      // REDIS is now flattened (no nested object)
      expect(result.secrets.REDIS_HOST).toBe('localhost');
      expect(result.secrets.REDIS_PORT).toBe('6379');
      expect(result.secrets.REDIS_PASSWORD).toBe('redis_pass');
      expect(result.secrets.REDIS_TLS).toBe('false');
    });

    it('should generate timestamp in ISO format', () => {
      const config = createMockFrameworkConfig();

      const result = generateFrameworkSecretsFile(config);

      expect(result.$generated_at).toMatch(/^\d{4}-\d{2}-\d{2}T/);
    });
  });

  describe('Framework secrets - no existing secrets', () => {
    it('should generate new framework secrets when none exist', () => {
      const config = createMockFrameworkConfig();

      const result = generateFrameworkSecretsFile(config);

      expect(result.secrets.NODE_ENV).toBe('development');
      expect(result.secrets.SECRETS_PROVIDER).toBe('local');
      expect(result.secrets.KONG_TRUST_TOKEN).toBe('mocked-hex-secret');
    });

    it('should include auth secrets when auth template is enabled', () => {
      const config = createMockFrameworkConfig({
        framework: { template: 'auth' },
      });

      const result = generateFrameworkSecretsFile(config);

      expect(result.secrets.REFRESH_TOKEN_SECRET).toBe('mocked-base64-secret');
      expect(result.secrets.JWT_PRIVATE_KEY_CURRENT).toBe('mocked-private-key');
      expect(result.secrets.JWT_PUBLIC_KEY_CURRENT).toBe('mocked-public-key');
      expect(result.secrets.JWT_KEY_ID_CURRENT).toBe('mocked-key-id');
      expect(result.secrets.BCRYPT_ROUNDS).toBe('12');
    });
  });

  describe('Framework secrets - with existing secrets', () => {
    it('should preserve existing REFRESH_TOKEN_SECRET when auth template is enabled', () => {
      const config = createMockFrameworkConfig({
        framework: { template: 'auth' },
      });

      const existingSecrets: SecretsFile = {
        secrets: {
          REFRESH_TOKEN_SECRET: 'existing-refresh-secret',
        },
      };

      const result = generateFrameworkSecretsFile(config, existingSecrets);

      expect(result.secrets.REFRESH_TOKEN_SECRET).toBe(
        'existing-refresh-secret',
      );
      expect(
        generateBase64SecretModule.generateBase64Secret,
      ).not.toHaveBeenCalled();
    });

    it('should generate missing REFRESH_TOKEN_SECRET when auth template is enabled', () => {
      const config = createMockFrameworkConfig({
        framework: { template: 'auth' },
      });

      const existingSecrets: SecretsFile = {
        secrets: {
          // REFRESH_TOKEN_SECRET is missing
        },
      };

      const result = generateFrameworkSecretsFile(config, existingSecrets);

      expect(result.secrets.REFRESH_TOKEN_SECRET).toBe('mocked-base64-secret');
      expect(
        generateBase64SecretModule.generateBase64Secret,
      ).toHaveBeenCalledWith(32);
    });

    it('should always set NODE_ENV and SECRETS_PROVIDER', () => {
      const config = createMockFrameworkConfig();

      const existingSecrets: SecretsFile = {
        secrets: {},
      };

      const result = generateFrameworkSecretsFile(config, existingSecrets);

      expect(result.secrets.NODE_ENV).toBe('development');
      expect(result.secrets.SECRETS_PROVIDER).toBe('local');
    });

    it('should handle existing REFRESH_TOKEN_SECRET with non-string value', () => {
      const config = createMockFrameworkConfig({
        framework: { template: 'auth' },
      });

      const existingSecrets: SecretsFile = {
        secrets: {
          REFRESH_TOKEN_SECRET: null as unknown as string,
        },
      };

      const result = generateFrameworkSecretsFile(config, existingSecrets);

      // Should generate new secret when existing value is not a string
      expect(result.secrets.REFRESH_TOKEN_SECRET).toBe('mocked-base64-secret');
    });

    it('should handle existing REFRESH_TOKEN_SECRET with empty string', () => {
      const config = createMockFrameworkConfig({
        framework: { template: 'auth' },
      });

      const existingSecrets: SecretsFile = {
        secrets: {
          REFRESH_TOKEN_SECRET: '',
        },
      };

      const result = generateFrameworkSecretsFile(config, existingSecrets);

      // Should generate new secret when existing value is empty string
      expect(result.secrets.REFRESH_TOKEN_SECRET).toBe('mocked-base64-secret');
    });
  });

  describe('Auth secrets configuration', () => {
    it('should omit auth secrets when auth template is disabled', () => {
      const config = createMockFrameworkConfig({
        framework: { template: null },
      });

      const result = generateFrameworkSecretsFile(config);

      expect(result.secrets.AUTH_SECRET).toBeUndefined();
      expect(result.secrets.REFRESH_TOKEN_SECRET).toBeUndefined();
    });

    it('should not preserve auth secrets when auth template is disabled', () => {
      const config = createMockFrameworkConfig({
        framework: { template: null },
      });

      const existingSecrets: SecretsFile = {
        secrets: {
          AUTH_SECRET: 'existing-auth-secret',
          REFRESH_TOKEN_SECRET: 'existing-refresh-secret',
        },
      };

      const result = generateFrameworkSecretsFile(config, existingSecrets);

      expect(result.secrets.AUTH_SECRET).toBeUndefined();
      expect(result.secrets.REFRESH_TOKEN_SECRET).toBeUndefined();
    });
  });

  describe('Service-specific secrets', () => {
    it('should generate service config for backend service', () => {
      const config = createMockFrameworkConfig({
        services: [{ name: 'auth-service', type: 'nestjs', port: 3001 }],
      });

      const result = generateFrameworkSecretsFile(config);

      const authService = result['auth-service'] as Record<string, unknown>;
      expect(authService).toEqual({
        PORT: '3001',
        secrets: [
          'NODE_ENV',
          'LOG_LEVEL',
          'REDIS_HOST',
          'REDIS_PORT',
          'REDIS_PASSWORD',
          'REDIS_TLS',
          'KONG_TRUST_TOKEN',
          'AUTH_SERVICE_API_KEY',
          'AUTH_SERVICE_URL',
        ],
        API_KEY: 'mocked-hex-secret',
      });
    });

    it('should add API_KEY alias for each backend service', () => {
      const config = createMockFrameworkConfig({
        services: [
          { name: 'auth-service', type: 'nestjs', port: 3001 },
          { name: 'offers-service', type: 'nestjs', port: 3002 },
        ],
      });

      const result = generateFrameworkSecretsFile(config);

      // Each backend service should have API_KEY field pointing to its own service API key
      const authService = result['auth-service'] as Record<string, unknown>;
      expect(authService.API_KEY).toBe('mocked-hex-secret');

      const offersService = result['offers-service'] as Record<string, unknown>;
      expect(offersService.API_KEY).toBe('mocked-hex-secret');
    });

    it('should not add API_KEY alias for frontend services', () => {
      const config = createMockFrameworkConfig({
        services: [{ name: 'web', type: 'nextjs', port: 3000 }],
      });

      const result = generateFrameworkSecretsFile(config);

      const webService = result['web'] as Record<string, unknown>;
      expect(webService.API_KEY).toBeUndefined();
    });

    it('should generate service config for Next.js service', () => {
      const config = createMockFrameworkConfig({
        services: [{ name: 'web', type: 'nextjs', port: 3000 }],
      });

      const result = generateFrameworkSecretsFile(config);

      const web = result['web'] as Record<string, unknown>;
      expect(web).toEqual({
        PORT: '3000',
        secrets: ['KONG_INTERNAL_URL'],
      });
    });

    it('should generate empty secrets array for client-side frontends', () => {
      const config = createMockFrameworkConfig({
        services: [{ name: 'admin-ui', type: 'spa', port: 3002 }],
      });

      const result = generateFrameworkSecretsFile(config);

      const adminUi = result['admin-ui'] as Record<string, unknown>;
      expect(adminUi).toEqual({
        PORT: '3002',
        secrets: [],
      });
    });

    it('should filter auth secrets when auth template is disabled', () => {
      const config = createMockFrameworkConfig({
        framework: { template: null },
        services: [{ name: 'auth-service', type: 'nestjs', port: 3001 }],
      });

      const result = generateFrameworkSecretsFile(config);

      const authService = result['auth-service'] as Record<string, unknown>;
      // Should not include JWT keys and REFRESH_TOKEN_SECRET, but still include BACKEND_DEFAULT_SECRETS, KONG_TRUST_TOKEN, service API keys, and service URLs
      expect(authService.secrets).toEqual([
        'NODE_ENV',
        'LOG_LEVEL',
        'REDIS_HOST',
        'REDIS_PORT',
        'REDIS_PASSWORD',
        'REDIS_TLS',
        'KONG_TRUST_TOKEN',
        'AUTH_SERVICE_API_KEY',
        'AUTH_SERVICE_URL',
      ]);
    });

    it('should convert PORT to string', () => {
      const config = createMockFrameworkConfig({
        services: [{ name: 'api', type: 'nestjs', port: 8080 }],
      });

      const result = generateFrameworkSecretsFile(config);

      const api = result['api'] as Record<string, unknown>;
      expect(api.PORT).toBe('8080');
      expect(typeof api.PORT).toBe('string');
    });
  });

  describe('Database secrets', () => {
    it('should generate DATABASE_URL for service with database', () => {
      const config = createMockFrameworkConfig({
        services: [
          {
            name: 'auth-service',
            type: 'nestjs',
            port: 3001,
            hasDatabase: true,
          },
        ],
      });

      const result = generateFrameworkSecretsFile(config);

      const authService = result['auth-service'] as Record<string, unknown>;
      expect(authService.DATABASE_URL).toBe(
        'postgresql://db-user:db-password@localhost:5432/db-name',
      );
      expect(
        generateDatabaseSecretsModule.generateDatabaseSecrets,
      ).toHaveBeenCalledWith('auth-service', 5432, undefined, undefined);
    });

    it('should use custom databasePort if provided', () => {
      const config = createMockFrameworkConfig({
        services: [
          {
            name: 'user-service',
            type: 'nestjs',
            port: 3002,
            hasDatabase: true,
            databasePort: 5433,
          },
        ],
      });

      generateFrameworkSecretsFile(config);

      expect(
        generateDatabaseSecretsModule.generateDatabaseSecrets,
      ).toHaveBeenCalledWith('user-service', 5433, undefined, undefined);
    });

    it('should increment dbPortCounter for multiple services', () => {
      const config = createMockFrameworkConfig({
        services: [
          {
            name: 'auth-service',
            type: 'nestjs',
            port: 3001,
            hasDatabase: true,
          },
          {
            name: 'user-service',
            type: 'nestjs',
            port: 3002,
            hasDatabase: true,
          },
          {
            name: 'order-service',
            type: 'nestjs',
            port: 3003,
            hasDatabase: true,
          },
        ],
      });

      generateFrameworkSecretsFile(config);

      expect(
        generateDatabaseSecretsModule.generateDatabaseSecrets,
      ).toHaveBeenNthCalledWith(1, 'auth-service', 5432, undefined, undefined);
      expect(
        generateDatabaseSecretsModule.generateDatabaseSecrets,
      ).toHaveBeenNthCalledWith(2, 'user-service', 5433, undefined, undefined);
      expect(
        generateDatabaseSecretsModule.generateDatabaseSecrets,
      ).toHaveBeenNthCalledWith(3, 'order-service', 5434, undefined, undefined);
    });

    it('should not generate DATABASE_URL for service without database', () => {
      const config = createMockFrameworkConfig({
        services: [
          {
            name: 'api-gateway',
            type: 'nestjs',
            port: 3000,
            hasDatabase: false,
          },
        ],
      });

      const result = generateFrameworkSecretsFile(config);

      const apiGateway = result['api-gateway'] as Record<string, unknown>;
      expect(apiGateway.DATABASE_URL).toBeUndefined();
      expect(
        generateDatabaseSecretsModule.generateDatabaseSecrets,
      ).not.toHaveBeenCalled();
    });
  });

  describe('Multiple services', () => {
    it('should handle mixed service types', () => {
      const config = createMockFrameworkConfig({
        services: [
          { name: 'web', type: 'nextjs', port: 3000 },
          {
            name: 'auth-service',
            type: 'nestjs',
            port: 3001,
            hasDatabase: true,
          },
          { name: 'admin-ui', type: 'spa', port: 3002 },
        ],
      });

      const result = generateFrameworkSecretsFile(config);

      expect(result['web']).toBeDefined();
      expect(result['auth-service']).toBeDefined();
      expect(result['admin-ui']).toBeDefined();

      const authService = result['auth-service'] as Record<string, unknown>;
      const web = result['web'] as Record<string, unknown>;
      expect(authService.DATABASE_URL).toBeDefined();
      expect(web.DATABASE_URL).toBeUndefined();
    });
  });

  describe('Edge cases', () => {
    it('should handle empty services array', () => {
      const config = createMockFrameworkConfig();

      const result = generateFrameworkSecretsFile(config);

      expect(result.secrets).toBeDefined();
      expect(
        Object.keys(result).filter(
          (k) => !k.startsWith('$') && k !== 'secrets',
        ),
      ).toHaveLength(0);
    });

    it('should handle null existingFrameworkSecrets', () => {
      const config = createMockFrameworkConfig();

      const result = generateFrameworkSecretsFile(config, null);

      expect(result.secrets).toBeDefined();
      expect(result.secrets.KONG_TRUST_TOKEN).toBe('mocked-hex-secret');
    });

    it('should handle undefined existingFrameworkSecrets', () => {
      const config = createMockFrameworkConfig();

      const result = generateFrameworkSecretsFile(config, undefined);

      expect(result.secrets).toBeDefined();
      expect(result.secrets.KONG_TRUST_TOKEN).toBe('mocked-hex-secret');
    });

    it('should handle config without framework field', () => {
      const config = createMockFrameworkConfig({
        services: [{ name: 'api', type: 'nestjs', port: 3000 }],
      });

      const result = generateFrameworkSecretsFile(config);

      const api = result['api'] as Record<string, unknown>;
      const secrets = api.secrets as string[];
      // Without framework field, auth template is undefined (not enabled)
      // Backend services get: BACKEND_DEFAULT_SECRETS + KONG_TRUST_TOKEN + service API keys + service URLs
      expect(secrets).toEqual([
        'NODE_ENV',
        'LOG_LEVEL',
        'REDIS_HOST',
        'REDIS_PORT',
        'REDIS_PASSWORD',
        'REDIS_TLS',
        'KONG_TRUST_TOKEN',
        'API_API_KEY',
        'API_URL',
      ]);
    });
  });
});
