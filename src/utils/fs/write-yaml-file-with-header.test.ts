import { describe, it, expect, rs, beforeEach } from '@rstest/core';
import { writeYamlFileWithHeader } from './write-yaml-file-with-header';
import { CliError } from '../errors';
import * as fs from 'fs';

// Mock fs
rs.mock('fs', { mock: true });

describe('writeYamlFileWithHeader', () => {
  beforeEach(() => {
    rs.clearAllMocks();
  });

  it('should prepend header to YAML content', () => {
    const data = { name: 'test' };
    const header = '# This is a header comment\n';

    writeYamlFileWithHeader('/path/to/file.yaml', data, header);

    const writtenContent = rs.mocked(fs.writeFileSync).mock
      .calls[0][1] as string;
    expect(writtenContent).toMatch(/^# This is a header comment\n/);
    expect(writtenContent).toContain('name: test');
  });

  it('should handle multi-line headers', () => {
    const data = { version: '1.0.0' };
    const header = `# Generated file - DO NOT EDIT
# This file is auto-generated by the framework
# Any changes will be overwritten
`;

    writeYamlFileWithHeader('/path/to/file.yaml', data, header);

    const writtenContent = rs.mocked(fs.writeFileSync).mock
      .calls[0][1] as string;
    expect(writtenContent).toContain('# Generated file - DO NOT EDIT');
    expect(writtenContent).toContain('# This file is auto-generated');
    expect(writtenContent).toContain('version: 1.0.0');
  });

  it('should write data with default formatting', () => {
    const data = { outer: { inner: 'value' } };
    const header = '# Header\n';

    writeYamlFileWithHeader('/path/to/file.yaml', data, header);

    const writtenContent = rs.mocked(fs.writeFileSync).mock
      .calls[0][1] as string;
    expect(writtenContent).toContain('  inner: value');
  });

  it('should accept custom dump options', () => {
    const data = { name: 'test' };
    const header = '# Header\n';

    writeYamlFileWithHeader('/path/to/file.yaml', data, header, { indent: 4 });

    expect(fs.writeFileSync).toHaveBeenCalled();
  });

  it('should throw CliError when write fails', () => {
    rs.mocked(fs.writeFileSync).mockImplementationOnce(() => {
      throw new Error('EACCES: permission denied');
    });

    expect(() => {
      writeYamlFileWithHeader(
        '/restricted/file.yaml',
        { name: 'test' },
        '# Header\n',
      );
    }).toThrow(CliError);
  });

  it('should include file path in error message on failure', () => {
    rs.mocked(fs.writeFileSync).mockImplementationOnce(() => {
      throw new Error('Write failed');
    });

    try {
      writeYamlFileWithHeader('/bad/path.yaml', { name: 'test' }, '# Header\n');
      expect.fail('Should have thrown CliError');
    } catch (error) {
      expect(error).toBeInstanceOf(CliError);
      const cliError = error as CliError;
      expect(cliError.message).toContain('/bad/path.yaml');
      expect(cliError.context).toBe('YAML write failed');
    }
  });

  it('should handle empty header', () => {
    const data = { name: 'test' };

    writeYamlFileWithHeader('/path/to/file.yaml', data, '');

    const writtenContent = rs.mocked(fs.writeFileSync).mock
      .calls[0][1] as string;
    expect(writtenContent).toMatch(/^name: test/);
  });

  it('should preserve header without trailing newline', () => {
    const data = { name: 'test' };
    const header = '# No trailing newline';

    writeYamlFileWithHeader('/path/to/file.yaml', data, header);

    const writtenContent = rs.mocked(fs.writeFileSync).mock
      .calls[0][1] as string;
    expect(writtenContent).toMatch(/^# No trailing newlinename: test/);
  });
});
